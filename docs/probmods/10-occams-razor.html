<!DOCTYPE html>
<html>
<head>
  <title>ProbMods: Occam's Razor</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js" onload="renderMathInElement(document.body,{delimiters:[{left:'\\(',right:'\\)',display:false},{left:'\\[',right:'\\]',display:true}]})"></script>
  <script src="../js/editor.js"></script>
  <script src="../js/physics.js"></script>
  <script>ProbPhysics.setup();</script>
  <script src="https://cdn.jsdelivr.net/npm/scittle@0.7.28/dist/scittle.js" crossorigin="anonymous"></script>
</head>
<body>
<div id="chapter-wrapper">
  <div id="header">
    <div id="logotype"><a href="index.html">Probabilistic Models of Cognition</a></div>
    <ul id="nav">
      <li><a href="09-hierarchical-models.html">&larr; Prev</a></li>
      <li><a href="index.html">Index</a></li>
      <li><a href="11-mixture-models.html">Next &rarr;</a></li>
    </ul>
  </div>
  <div id="chapter">


<h1 id="chapter-title">10. Occam&rsquo;s Razor</h1>

<div class="toc">
<div class="name">Contents:</div>
<ul>
<li><a href="#occams-razor">Occam&rsquo;s Razor</a></li>
<li><a href="#the-size-principle">The Size Principle</a></li>
<li><a href="#generalizing-the-size-principle">Generalizing the Size Principle: Bayes Occam&rsquo;s Razor</a></li>
<li><a href="#model-selection">Model Selection with the Bayesian Occam&rsquo;s Razor</a></li>
<li><a href="#scene-inference">Example: Scene Inference</a></li>
</ul>
</div>


<blockquote>
<p><em>Entities should not be multiplied without necessity.</em> &mdash;William of Ockham</p>
</blockquote>

<p>In learning, perceiving or thinking about the world, we are fitting models to the data of experience. Typically our hypothesis space will span models varying greatly in complexity: some models will have many more free parameters or degrees of freedom than others. Under traditional approaches to model fitting where we adjust each model&rsquo;s parameters until it fits best, then choose the best-fitting model &mdash; a model with strictly more free parameters will tend to be preferred regardless of whether it actually comes closer to describing the true processes that generated the data. But this is not the way the mind works. We assess models with a natural eye for complexity, balancing fit to the data with model complexity in subtle ways that will not inevitably prefer the most complex model. Instead we often seem to judge models using Occam&rsquo;s razor: we choose the least complex hypothesis that fits the data well. In doing so we avoid &ldquo;over-fitting&rdquo; our data in order to support successful generalizations and predictions.</p>

<p>Fitting curves (or smooth functions) to sparsely sampled, noisy data provides a familiar example of the problem. Consider three polynomial fits: a 1st-order (linear), a 2nd-order (quadratic), and a 12th-order polynomial. How do our minds decide which of these functions provides the best account of the data? The 1st-order model captures the rough trend of the data but seems too coarse; it attributes some of the variation that we see as &ldquo;signal&rdquo; to &ldquo;noise&rdquo;. The 2nd-order model seems best; it seems to be just complex enough to fit the main shape of the data without over-fitting the noise. The 12th-order model seems ridiculously over-fit; with 13 data points, the parameters can be adjusted so as to make the curve pass exactly through every data point, thus taking as &ldquo;signal&rdquo; all of what we see as &ldquo;noise&rdquo;. Again we can think of this as a causal inference problem: each function represents a hypothesis about the causal process that gave rise to the observed data, including the shape of the function from inputs to outputs, as well as the level of noise added to the output.</p>


<h1 id="occams-razor"><a href="#occams-razor">Occam&rsquo;s Razor</a></h1>

<p>An elegant and powerful form of Occam&rsquo;s razor arises in the context of Bayesian inference, known as the <em>Bayesian Occam&rsquo;s razor</em>. Bayesian Occam&rsquo;s razor refers to the fact that &ldquo;more complex&rdquo; hypotheses about the data are penalized automatically in conditional inference. In many formulations of Occam&rsquo;s razor, complexity is measured <em>syntactically</em>: for instance, it may be the description length of the hypothesis in some representation language, or a count of the number of free parameters needed to pick out the hypothesis from some larger model class. Syntactic forms of Occam&rsquo;s razor have difficulty justifying the complexity measure on principled, non-arbitrary grounds. They also leave unspecified exactly how the weight of a complexity penalty should trade off with an alternative measure of fit to the data. Fit is intrinsically a <em>semantic</em> notion, a matter of correspondence between the model&rsquo;s predictions and our observations of the world. When complexity is measured syntactically and fit is measured semantically, they are intrinsically incommensurable and the trade-off between them will always be to some extent arbitrary.</p>

<p>In the Bayesian Occam&rsquo;s razor, both complexity and fit are measured semantically. The semantic notion of complexity is a measure of <em>flexibility</em>: a hypothesis that is flexible enough to generate many different sets of observations is more complex, and will tend to receive lower posterior probability than a less flexible, simpler hypothesis that explains the same data. Because more complex hypotheses can generate a greater variety of data sets, they must necessarily assign a lower probability to each one. When we condition on some data, all else being equal, the posterior distribution over the hypotheses will favor the simpler ones because they have the <em>tightest</em> fit to the observations.</p>

<p>From the standpoint of a sampling-based probabilistic programming language, the Bayesian Occam&rsquo;s razor is essentially inescapable. We do not judge models based on their best fitting behavior but rather on their average behavior. No fitting per se occurs during conditional inference. Instead, we draw conditional samples from each model representing the model&rsquo;s likely ways of generating the data. A model that tends to fit the data well on average &mdash; to produce relatively many generative histories that are consistent with the data &mdash; will do better than a model that can fit better only for atypical parameter settings but worse on average.</p>

<h2>The Law of Conservation of Belief</h2>

<p>It is convenient to emphasize an aspect of probabilistic modeling that seems deceptively trivial, but comes up repeatedly when thinking about inference. In Bayesian statistics we think of probabilities as being <em>degrees of belief</em>. Our generative model reflects world knowledge and the probabilities that we assign to the possible sampled values reflect how strongly we believe in each possibility. The laws of probability theory ensure that our beliefs remain consistent as we reason.</p>

<p>A consequence of belief maintenance is known as the <em>Law of Conservation of Belief</em> (LCB). Here are two equivalent formulations of this principle:</p>

<ol>
<li>Sampling from a distribution selects exactly one possibility (in doing so it implicitly rejects all other possible values).</li>
<li>The total probability mass of a distribution must sum to \(1\). That is, we only have a single unit of belief to spread around.</li>
</ol>

<p>The latter formulation leads to a common metaphor in discussing generative models: We can usefully think of belief as a &ldquo;currency&rdquo; that is &ldquo;spent&rdquo; by the probabilistic choices required to construct a sample. Since each choice requires &ldquo;spending&rdquo; some currency, an outcome that requires more choices to construct it will generally be more costly, i.e. less probable.</p>

<p>It is this conservation of belief that gives rise to the Bayesian Occam&rsquo;s razor. A hypothesis that spends its probability on many alternatives that don&rsquo;t explain the current data will have less probability for the alternatives that do, and will hence do less well overall than a hypothesis which only entertains options that fit the current data. We next examine a special case where this tradeoff plays out clearly, the <em>size principle</em>, then come back to the more general cases.</p>


<h1 id="the-size-principle"><a href="#the-size-principle">The Size Principle</a></h1>

<p>A simple case of Bayes Occam&rsquo;s razor comes from the <em>size principle</em> (Tenenbaum, 2001): Of hypotheses which generate data uniformly, the one consistent with the data and with smallest extension is the most probable.</p>

<p>The following program demonstrates the size principle with a very simple model. Here we have two hypothesized sets: <code>Big</code> has 6 elements and <code>Small</code> has 3 elements. The generative model chooses one of the hypotheses at random and samples some number of symbols from it uniformly. We then wish to infer the hypothesis given observed elements.</p>

<pre><code>(def samples
  (mh-query
   100 100
   (let [hypothesis->set (fn [hyp]
                           (if (= hyp 'Big)
                             ['a 'b 'c 'd 'e 'f]
                             ['a 'b 'c]))
         hypothesis (if (flip) 'Big 'Small)
         observe-fn (fn [n]
                      (repeatedly n
                        (fn [] (uniform-draw (hypothesis->set hypothesis)))))]
     (condition (= (observe-fn 1) ['a]))
     hypothesis)))

(hist samples "Size Principle")</code></pre>

<p>With a single observed <code>a</code>, we already favor hypothesis <code>Small</code>. What happens when we increase the amount of observed data? Consider the learning trajectory:</p>

<pre><code>(defn run-samples [data]
  (mh-query
   100 10
   (let [hypothesis->set (fn [hyp]
                           (if (= hyp 'Big)
                             ['a 'b 'c 'd 'e 'f]
                             ['a 'b 'c]))
         hypothesis (if (flip) 'Big 'Small)
         observe-fn (fn [n]
                      (vec (repeatedly n
                        (fn [] (uniform-draw (hypothesis->set hypothesis))))))]
     (condition (= (observe-fn (count data)) data))
     hypothesis)))

(defn big-freq [data]
  (mean (map (fn [hyp] (if (= hyp 'Big) 1.0 0.0))
             (run-samples data))))

(lineplot
 (mapv vector
   [1 3 5 7]
   [(big-freq ['a])
    (big-freq ['a 'b 'a])
    (big-freq ['a 'b 'a 'b 'b])
    (big-freq ['a 'b 'a 'b 'b 'a 'b])])
 "P(Big | observations)")</code></pre>

<p>As the number of data points increases, the hypothesis <code>Small</code> rapidly comes to dominate the posterior distribution. Why is this happening? We sample observations uniformly from hypotheses, the law of conservation of belief and the symmetry between observations imply that the probability of a draw from <code>Big</code> is \(\frac{1}{6}\), while the probability of a draw from <code>Small</code> is \(\frac{1}{3}\). Thus, by the product rule of probabilities, the probability of drawing a set of N observations from <code>Big</code> is \((\frac{1}{6})^N\), while the probability of drawing a set of observations from <code>Small</code> is \((\frac{1}{3})^N\). The latter probability decreases much more slowly than the former as the number of observations increases. Using Bayes&rsquo; rule, the posterior distribution over hypotheses is given by:</p>

\[P(\text{hypothesis} \mid \text{observations}) \propto P(\text{observations} \mid \text{hypothesis})P(\text{hypothesis})\]

<p>Because our hypotheses are equally probable a priori, this simplifies to:</p>

\[P(\text{hypothesis} \mid \text{observations}) \propto P(\text{observations} \mid \text{hypothesis})\]

<p>So we see that the posterior distribution over hypotheses in this case is just the normalized likelihood \(P(\text{observations} \mid \text{hypothesis})\). The likelihood ratio \(P(\text{observations} \mid \text{Big})/P(\text{observations} \mid \text{Small}) = (\frac{1}{2})^N\) determines how quickly the simpler hypothesis <code>Small</code> comes to dominate the posterior.</p>

<p>The size principle is related to an influential proposal in linguistics known as the <em>subset principle</em>. Intuitively, the subset principle suggests that when two grammars both account for the same data, the grammar that generates a smaller language should be preferred.</p>

<h2>The Size Principle and Implicit Negative Evidence</h2>

<p>One way to understand the Size Principle is that probabilistic inference takes into account implicit negative evidence. More flexible hypotheses could have generated more observations. Thus if those hypotheses were the true hypotheses we would expect to see a greater variety of observations. If the data does not contain them, this is a form of negative evidence against those hypotheses. Importantly, the Size Principle tells us that the prior distribution on hypotheses does not have to penalize complexity. The complexity of the hypothesis itself will lead to its being disfavored in the posterior distribution.</p>


<h1 id="generalizing-the-size-principle"><a href="#generalizing-the-size-principle">Generalizing the Size Principle: Bayes Occam&rsquo;s Razor</a></h1>

<p>In our example above we have illustrated Bayes Occam&rsquo;s razor with examples based strictly on the &ldquo;size&rdquo; of the hypotheses involved, however, the principle is more general. Bayes&rsquo; Occam razor says that all else being equal the hypothesis that assigns the highest likelihood to the data will dominate the posterior. Because of the law of conservation of belief, assigning higher likelihood to the observed data requires assigning lower likelihood to other possible data. Consider the following example:</p>

<pre><code>(def observed-letters ['a 'b 'a 'b 'c 'd 'b 'b])

(def samples
  (mh-query
   100 100
   (let [hypothesis->parameters
           (fn [hyp]
             (if (= hyp 'A)
               [['a 'b 'c 'd] [0.375 0.375 0.125 0.125]]
               [['a 'b 'c 'd] [0.25 0.25 0.25 0.25]]))
         hypothesis (if (flip) 'A 'B)]
     (doseq [letter observed-letters]
       (condition (= (multinomial
                       (first (hypothesis->parameters hypothesis))
                       (second (hypothesis->parameters hypothesis)))
                     letter)))
     hypothesis)))

(hist samples "Bayes-Occam-Razor")</code></pre>

<p>In this example, unlike the size principle cases above, both hypotheses lead to the same possible observed values. However, hypothesis A is skewed toward examples a and b &mdash; while it can produce c or d, it is less likely to do so. In this sense hypothesis A is less flexible than hypothesis B. The data set we conditioned on also has exemplars of all the elements in the support of the two hypotheses. However, because there are more exemplars of elements favored by hypothesis <code>A</code>, this hypothesis is favored in the posterior. The Bayesian Occam&rsquo;s razor emerges naturally here, and is often described as favoring the less flexible hypothesis.</p>

<p>Similar effects emerge if hypothesis B is not uniform, but favors different examples than hypothesis A:</p>

<pre><code>(def observed-letters ['a 'b 'a 'c 'd])

(def samples
  (mh-query
   100 100
   (let [hypothesis->parameters
           (fn [hyp]
             (if (= hyp 'A)
               [['a 'b 'c 'd] [0.375 0.375 0.125 0.125]]
               [['a 'b 'c 'd] [0.25 0.25 0.25 0.25]]))
         hypothesis (if (flip) 'A 'B)]
     (doseq [letter observed-letters]
       (condition (= (multinomial
                       (first (hypothesis->parameters hypothesis))
                       (second (hypothesis->parameters hypothesis)))
                     letter)))
     hypothesis)))

(hist samples "Bayes-Occam-Razor")</code></pre>

<p>Try changing the observed letters to <code>['d 'c 'd 'a 'b]</code>. How does the inference change? Note that it takes less evidence here to favor hypothesis A than when B is uniform, but still more than in a size principle case (where A wouldn&rsquo;t be able to generate c or d at all) &mdash; but the size principle case would be unable to handle the &ldquo;exceptional&rdquo; observations of c and d. This example suggests another way to understand Bayes Occam&rsquo;s razor: the posterior distribution will favor hypotheses for which the data set is simpler in the sense that it is more &ldquo;easily generated.&rdquo; Here more &ldquo;easily&rdquo; generated means generated with higher probability. We will see a more striking example of this for compositional models at the end of this section of the tutorial.</p>


<h1 id="model-selection"><a href="#model-selection">Model Selection with the Bayesian Occam&rsquo;s Razor</a></h1>

<p>The law of conservation of belief turns most clearly into Occam&rsquo;s Razor when we consider models with more internal structure: some continuous or discrete parameters that at different settings determine how likely the model is to produce data that look more or less like our observations. To select among models we simply need to describe each model as a probabilistic program, and also to write a higher-level program that generates these hypotheses. Inference will then automatically draw samples at both of these levels of abstraction, asking which models are most likely to have given rise to the observed data, as well as for each of those models, which internal parameter settings are most likely. Note that we are dealing with <a href="http://en.wikipedia.org/wiki/Statistical_model"><em>statistical models</em></a>, which are stochastic, rather than deterministic.</p>

<h2>Example: Fair or unfair coin?</h2>

<p>In the previous section we considered learning about the weight of a coin, and noted that a simple prior on weights seemed unable to capture our more discrete intuition that we first decide if the coin is fair or not, and only then worry about its weight. This example shows how our inferences about coin flipping can be explained in terms of model selection guided by the Bayesian Occam&rsquo;s razor. Imagine a coin that you take out of a freshly unwrapped roll of quarters straight from the bank. Almost surely this coin is fair... But how does that sense change when you see more or less anomalous sequences of flips? We can simultaneously ask if the coin is fair, and what is its weight.</p>

<pre><code>;; fair coin, probability of H = 0.5
(def observed-data ['h 'h 't 'h 't 'h 'h 'h 't 'h])

;; Try uncommenting different data sets:
;; (def observed-data ['h 'h 'h 'h 'h 'h 'h 'h 'h 'h])
;; (def observed-data ['h 'h 'h 'h 'h 'h 'h 'h 'h 'h 'h 'h 'h 'h 'h])

(def num-flips (count observed-data))
(def num-samples 1000)
(def fair-prior 0.999)
(def pseudo-counts [1 1])

(def prior-samples
  (repeatedly num-samples
    (fn [] (if (flip fair-prior)
             0.5
             (beta (first pseudo-counts) (second pseudo-counts))))))

(def samples
  (mh-query
   num-samples 10
   (let [fair-coin? (flip fair-prior)
         coin-weight (if fair-coin?
                       0.5
                       (beta (first pseudo-counts) (second pseudo-counts)))]
     (doseq [datum observed-data]
       (condition (= (flip coin-weight) (= datum 'h))))
     [(if fair-coin? 'fair 'unfair) coin-weight])))

(hist (map first samples) "Fair coin?")
(density (concat [0] [1] prior-samples) "Coin weight, prior to observing data")
(density (concat [0] [1] (map second samples)) "Coin weight, conditioned on observed data")</code></pre>

<p>Try some of the other cases that we&rsquo;ve commented out above and see if the inferences accord with your intuitions.</p>

<p>Now let&rsquo;s look at the learning trajectories for this model:</p>

<pre><code>(def fair-prior 0.999)
(def pseudo-counts [1 1])

(defn run-samples [data]
  (mh-query 400 10
    (let [fair-coin? (flip fair-prior)
          coin-weight (if fair-coin?
                        0.5
                        (beta (first pseudo-counts) (second pseudo-counts)))]
      (doseq [datum data]
        (condition (= (flip coin-weight) (= datum 'h))))
      coin-weight)))

(def make-coin (fn [weight] (fn [] (if (flip weight) 'h 't))))
(def true-coin (make-coin 0.9))
(def full-data-set (vec (repeatedly 100 true-coin)))
(def observed-data-sizes [1 3 6 10 20 30 50 70 100])

(defn estimate [n]
  (mean (run-samples (vec (take n full-data-set)))))

(lineplot
 (mapv (fn [n] [n (estimate n)])
   observed-data-sizes)
 "Learning trajectory")</code></pre>

<p>In general (though not on every run) the learning trajectory stays near 0.5 initially &mdash; favoring the simpler hypothesis that the coin is fair &mdash; then switches fairly abruptly to near 0.9 &mdash; as it infers that it is an unfair coin and likely has high weight. Here the Bayesian Occam&rsquo;s Razor penalizes the hypothesis with the flexibility to learn any coin weight: we automatically get a notion of comparing the complexity of very differently-structured models.</p>

<h2>The Effect of Unused Parameters</h2>

<p>When statisticians suggest methods for model selection, they often include a penalty for the <em>number</em> of parameters (e.g., <a href="http://en.wikipedia.org/wiki/Akaike_information_criterion">AIC</a>). This seems like a worrying policy from the point of view of a probabilistic program: we could always introduce parameters that are not used, and therefore have no effect on the program. For instance we could change the above coin flipping example so that it draws the potential unfair coin weight even in the model which gives a fair coin:</p>

<pre><code>(def observed-data ['h])
(def fair-prior 0.5)

(def samples
  (mh-query
   1000 10
   (let [unfair-coin-weight (beta 1 10)
         fair-coin? (flip fair-prior)
         coin-weight (if fair-coin?
                       0.5
                       unfair-coin-weight)]
     (doseq [datum observed-data]
       (condition (= (flip coin-weight) (= datum 'h))))
     [(if fair-coin? 'fair 'unfair) coin-weight])))

(hist (map first samples) "Fair coin?")</code></pre>

<p>The two models now have the same number of free parameters (the unfair coin weight), but we will still favor the simpler hypothesis, as we did above. Why? The Bayesian Occam&rsquo;s razor penalizes models not for having more parameters (or longer code) but for too much flexibility &mdash; being able to fit too many other potential observations. Unused parameters (or parameters with very little effect) don&rsquo;t increase this flexibility, and hence aren&rsquo;t penalized. The Bayesian Occam&rsquo;s razor only penalizes complexity that matters for prediction, and only to the extent that it matters.</p>


<h1 id="scene-inference"><a href="#scene-inference">Example: Scene Inference</a></h1>

<p>Imagine you are in a world of colored blocks that typically looks something like a grid of colored squares. And one day you see a 1x2 red patch... is it one 1x2 block or two 1x1 blocks?</p>

<p>We can model this inference by building a generative model of scenes. To do so we use simple models of geometry and of rendering geometric objects to an image (in this case by layering them):</p>

<pre><code>;; take an object and "render" it into an image (list of lists):
(defn object-appearance [object]
  (let [[ox oy oh oc] object]
    (mapv (fn [pixel-y]
            (mapv (fn [pixel-x]
                    (if (or (< pixel-x ox)
                            (<= (+ ox 1) pixel-x)
                            (< pixel-y oy)
                            (<= (+ oy oh) pixel-y))
                      0
                      oc))
                  (range 4)))
          (range 2))))

;; layer the image of an object onto a "background" image
(defn layer [obj image]
  (mapv (fn [obj-row im-row]
          (mapv (fn [o i] (if (= 0 o) i o))
                obj-row im-row))
        obj image))

;; prior distribution over objects' properties
(defn sample-properties []
  [(random-integer 4)          ;; x location
   (random-integer 2)          ;; y location
   (+ 1 (random-integer 2))    ;; vertical size
   (+ 1 (random-integer 2))])  ;; color

;; Now we infer how many objects, given an ambiguous observed image:
(def observed-image [[0 1 0 0] [0 1 0 0]])

(def samples
  (mh-query 500 10
    (let [num-objects (if (flip) 1 2)
          object1 (sample-properties)
          object2 (sample-properties)
          image1 (if (= num-objects 1)
                   (object-appearance object1)
                   (layer (object-appearance object1)
                          (object-appearance object2)))]
      (condition (= image1 observed-image))
      num-objects)))

(hist samples "Number of objects")</code></pre>

<p>There is a slight preference for one object over two.</p>

<p>Now let&rsquo;s see what happens if we see the two &ldquo;halves&rdquo; moving together. We use a simple random drift model of motion: an object randomly moves right or left or stays in place. Critically, the motion of each object is independent of other objects.</p>

<pre><code>;; rendering functions (same as above):
(defn object-appearance [object]
  (let [[ox oy oh oc] object]
    (mapv (fn [pixel-y]
            (mapv (fn [pixel-x]
                    (if (or (< pixel-x ox)
                            (<= (+ ox 1) pixel-x)
                            (< pixel-y oy)
                            (<= (+ oy oh) pixel-y))
                      0
                      oc))
                  (range 4)))
          (range 2))))

(defn layer [obj image]
  (mapv (fn [obj-row im-row]
          (mapv (fn [o i] (if (= 0 o) i o))
                obj-row im-row))
        obj image))

;; motion model: drift left/right/stay
(defn move [object]
  (let [dx (multinomial [-1 0 1] [0.3 0.4 0.3])]
    (assoc (vec object) 0 (+ (first object) dx))))

(defn sample-properties []
  [(random-integer 4) (random-integer 2)
   (+ 1 (random-integer 2)) (+ 1 (random-integer 2))])

;; Two "frames" of an ambiguous movie:
(def observed-image1 [[0 1 0 0] [0 1 0 0]])
(def observed-image2 [[0 0 1 0] [0 0 1 0]])

(def samples
  (mh-query 1000 10
    (let [num-objects (if (flip) 1 2)
          object1 (sample-properties)
          object2 (sample-properties)
          image1 (if (= num-objects 1)
                   (object-appearance object1)
                   (layer (object-appearance object1)
                          (object-appearance object2)))
          ;; second image from motion on objects:
          image2 (if (= num-objects 1)
                   (object-appearance (move object1))
                   (layer (object-appearance (move object1))
                          (object-appearance (move object2))))]
      (condition (and (= image1 observed-image1)
                      (= image2 observed-image2)))
      num-objects)))

(hist samples "Number of objects, moving image")</code></pre>

<p>We see that there is a much stronger preference for the one object interpretation. It is a much bigger coincidence (as measured by Bayes Occam&rsquo;s Razor) for the two halves to move together if they are unconnected, than if they are connected, or if they are merely seen statically next to each other.</p>

<p>We see from these examples that several of the gestalt principles for perceptual grouping emerge from this probabilistic scene inference setup (in this case &ldquo;good continuation&rdquo; and &ldquo;common fate&rdquo;). However, these are graded inferences, rather than hard rules: in this case we found that the information available in a static image was much weaker than the information in a moving image (and hence good continuation was weaker than common fate). This effect may have important developmental implications: the psychologist Elizabeth Spelke has found that young infants do not group objects by any static features (such as good continuation) but they do group them by common motion (see Spelke, 1990, Cognitive Science).</p>


<h1 id="references"><a href="#references">References</a></h1>

<p>Spelke, E. S. (1990). Principles of object perception. <em>Cognitive Science</em>, <em>14</em>(1), 29&ndash;56.</p>
<p>Tenenbaum, J. B. (2000). Rules and similarity in concept learning. In <em>Advances in Neural Information Processing Systems 12</em>.</p>
<p>Tenenbaum, J. B., &amp; Griffiths, T. L. (2001). Generalization, similarity, and Bayesian inference. <em>Behavioral and Brain Sciences</em>, <em>24</em>(4), 629&ndash;640.</p>


  </div>
  <div class="chapter-nav">
    <a href="09-hierarchical-models.html">&larr; Chapter 9: Hierarchical Models</a>
    <a href="11-mixture-models.html">Chapter 11: Mixture Models &rarr;</a>
  </div>
</div>

<!-- Interactive runner: loads prob-cljs via fetch + eval_string -->
<script>
var _scittleReady = false;
var _scittleLoading = null;

function ensureScittleImports() {
  if (_scittleReady) return Promise.resolve();
  if (_scittleLoading) return _scittleLoading;

  var files = [
    '../prob/math.cljs',
    '../prob/erp.cljs',
    '../prob/dist.cljs',
    '../prob/cps_transform.cljc',
    '../prob/cps.cljs',
    '../prob/inference.cljs',
    '../prob/builtins.cljs',
    '../prob/core.cljs',
    'viz.cljs'
  ];

  _scittleLoading = Promise.all(files.map(function(f) {
    return fetch(f).then(function(r) {
      if (!r.ok) throw new Error('Failed to load ' + f + ': ' + r.status);
      return r.text();
    });
  })).then(function(sources) {
    sources.forEach(function(src) { scittle.core.eval_string(src); });

    scittle.core.eval_string(
      "(ns prob.macros)" +
      "(defmacro rejection-query [& body] `(prob.core/rejection-query-fn (fn [] ~@body)))" +
      "(defmacro mh-query [n lag & body] `(prob.core/mh-query-fn ~n ~lag (fn [] ~@body)))" +
      "(defmacro enumeration-query [& body] `(prob.core/enumeration-query-fn (fn [] ~@body)))"
    );

    scittle.core.eval_string(
      "(require '[prob.core :refer [flip gaussian uniform uniform-draw random-integer multinomial" +
      "                              sample-discrete beta gamma dirichlet exponential" +
      "                              binomial poisson categorical" +
      "                              condition factor observe rejection-query-fn mh-query-fn" +
      "                              enumeration-query-fn mem mean variance sum prod" +
      "                              sample* observe* dist? enumerate*]])" +
      "(require '[prob.dist :refer [observe* sample* dist? enumerate*" +
      "                              gaussian-dist bernoulli-dist uniform-dist beta-dist gamma-dist" +
      "                              exponential-dist dirichlet-dist uniform-draw-dist" +
      "                              random-integer-dist multinomial-dist sample-discrete-dist" +
      "                              binomial-dist poisson-dist categorical-dist]])" +
      "(require '[prob.builtins :refer [expt member pair null? equal? make-list length" +
      "                                  string-append abs sample fold iota]])" +
      "(require '[prob.macros :refer [rejection-query mh-query enumeration-query]])" +
      "(require '[prob.viz :refer [hist density scatter barplot lineplot display run-physics animate-physics]])"
    );

    _scittleReady = true;
  });

  return _scittleLoading;
}

function runCode(code, output) {
  output.innerHTML = '';
  window.__currentOutput = output;
  window.__appendToOutput = function(el) { window.__currentOutput.appendChild(el); };
  window.__appendTextToOutput = function(text) {
    var span = document.createElement('span');
    span.textContent = text + '\n';
    window.__currentOutput.appendChild(span);
  };
  ensureScittleImports().then(function() {
    window.__currentOutput = output;
    try {
      var result = scittle.core.eval_string(code);
      if (result != null) {
        var span = document.createElement('span');
        span.textContent = '' + result;
        output.appendChild(span);
      }
    } catch(e) {
      var span = document.createElement('span');
      span.className = 'error';
      span.textContent = 'Error: ' + e.message;
      output.appendChild(span);
    }
  }).catch(function(e) {
    var span = document.createElement('span');
    span.className = 'error';
    span.textContent = 'Load error: ' + e.message;
    output.appendChild(span);
  });
}

document.querySelectorAll('#chapter pre:not(.norun)').forEach(function(pre) {
  var codeEl = pre.querySelector('code');
  if (!codeEl) return;
  var code = codeEl.textContent.trim();

  var container = document.createElement('div');
  container.className = 'code-example';

  var editorDiv = document.createElement('div');

  var toolbar = document.createElement('div');
  toolbar.className = 'toolbar';

  var btn = document.createElement('button');
  btn.textContent = 'Run';

  var output = document.createElement('div');
  output.className = 'output';

  toolbar.appendChild(btn);
  container.appendChild(editorDiv);
  container.appendChild(toolbar);
  container.appendChild(output);
  pre.replaceWith(container);

  var editor = ProbEditor.createEditor(editorDiv, code, {
    onEval: function(code) { runCode(code, output); }
  });

  btn.addEventListener('click', function() {
    runCode(editor.getCode(), output);
  });
});
</script>
</body>
</html>
