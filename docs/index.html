<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>prob-cljs</title>
  <style>
    body { font-family: -apple-system, system-ui, sans-serif; max-width: 860px; margin: 0 auto; padding: 20px; }
    h1 a { color: inherit; text-decoration: none; }
    .subtitle { color: #666; }
    pre { background: #f0f0f0; padding: 12px; border-radius: 4px; font-size: 13px; overflow-x: auto; }
    #output { background: #1e1e2e; color: #cdd6f4; padding: 20px; border-radius: 8px; font-family: monospace; font-size: 13px; min-height: 100px; white-space: pre-wrap; }
    .btn { background: #3b82f6; color: white; border: none; padding: 8px 20px; border-radius: 4px; cursor: pointer; font-size: 14px; margin: 8px 0; }
    .btn:hover { background: #2563eb; }
    .btn:disabled { background: #94a3b8; cursor: not-allowed; }
    footer { margin-top: 40px; color: #888; font-size: 13px; text-align: center; }
    footer a { color: #3b82f6; }
  </style>
</head>
<body>
  <h1><a href="https://github.com/robert-johansson/prob-cljs">prob-cljs</a></h1>
  <p class="subtitle">Probabilistic programming as a ClojureScript library</p>
  <p>Running inference directly in your browser via <a href="https://github.com/babashka/scittle">Scittle</a>.</p>

  <button class="btn" id="run-btn" disabled>Loading...</button>
  <div id="output"></div>

  <footer>
    <a href="https://github.com/robert-johansson/prob-cljs">GitHub</a>
  </footer>

  <script>console.log("page loaded, loading scittle...")</script>
  <script src="https://cdn.jsdelivr.net/npm/scittle@0.7.28/dist/scittle.js" crossorigin="anonymous"></script>
  <script>console.log("scittle script tag done")</script>

  <!-- ERPs -->
  <script type="application/x-scittle">
  (ns prob.erp)

  (defn- rand-uniform [] (js/Math.random))

  (defn flip
    ([] (< (rand-uniform) 0.5))
    ([p] (< (rand-uniform) p)))

  (defn uniform [a b]
    (+ a (* (rand-uniform) (- b a))))

  (defn uniform-draw [lst]
    (let [items (vec lst)
          n (count items)]
      (nth items (js/Math.floor (* (rand-uniform) n)))))

  (defn random-integer [n]
    (js/Math.floor (* (rand-uniform) n)))

  (defn multinomial [items probs]
    (let [items (vec items)
          probs (vec probs)
          total (reduce + 0 probs)
          r (* (rand-uniform) total)]
      (loop [i 0, cumulative 0]
        (if (>= i (count items))
          (peek items)
          (let [cumulative (+ cumulative (nth probs i))]
            (if (< r cumulative)
              (nth items i)
              (recur (inc i) cumulative)))))))

  (defn sample-discrete [weights]
    (let [weights (vec weights)
          indices (vec (range (count weights)))]
      (multinomial indices weights)))

  (defn gaussian
    ([] (gaussian 0 1))
    ([mu sigma]
     (if (zero? sigma)
       mu
       (let [u1 (rand-uniform)
             u2 (rand-uniform)
             z (* (js/Math.sqrt (* -2 (js/Math.log u1)))
                  (js/Math.cos (* 2 js/Math.PI u2)))]
         (+ mu (* sigma z))))))

  (defn gamma [a b]
    (if (< a 1)
      (* (gamma (inc a) b)
         (js/Math.pow (rand-uniform) (/ 1 a)))
      (let [d (- a (/ 1 3))
            c (/ 1 (js/Math.sqrt (* 9 d)))]
        (loop []
          (let [x (gaussian 0 1)
                v (js/Math.pow (+ 1 (* c x)) 3)]
            (if (and (> v 0)
                     (< (js/Math.log (rand-uniform))
                        (+ (* 0.5 x x)
                           (* d (- 1 v (js/Math.log v))))))
              (* d v b)
              (recur)))))))

  (defn beta [a b]
    (let [x (gamma a 1) y (gamma b 1)]
      (/ x (+ x y))))

  (defn dirichlet [alpha-vec]
    (let [alpha (vec alpha-vec)
          samples (mapv #(gamma % 1) alpha)
          total (reduce + 0 samples)]
      (mapv #(/ % total) samples)))

  (defn exponential [rate]
    (/ (- (js/Math.log (rand-uniform))) rate))

  (js/console.log "prob.erp loaded")
  </script>

  <!-- Inference -->
  <script type="application/x-scittle">
  (ns prob.inference
    (:require [prob.erp :as erp]))

  (def ^:private rejection-sentinel ::rejection)

  (defn condition [pred]
    (when-not pred
      (throw (ex-info "condition failed" {::type rejection-sentinel})))
    nil)

  (defn factor [log-weight]
    (when (neg? log-weight)
      (when (> (js/Math.log (js/Math.random)) log-weight)
        (throw (ex-info "factor rejected" {::type rejection-sentinel}))))
    nil)

  (defn- rejection? [e]
    (and (ex-data e)
         (= (::type (ex-data e)) rejection-sentinel)))

  (def ^:private max-rejection-attempts 10000)

  (defn rejection-query-fn [thunk]
    (loop [attempts 0]
      (if (>= attempts max-rejection-attempts)
        (throw (ex-info "rejection-query: exceeded max attempts" {}))
        (let [result (try
                       {:value (thunk)}
                       (catch :default e
                         (if (rejection? e)
                           ::rejected
                           (throw e))))]
          (if (= result ::rejected)
            (recur (inc attempts))
            (:value result))))))

  (defn mh-query-fn [num-samples lag thunk]
    (let [sample-one (fn []
                       (loop [attempts 0]
                         (if (>= attempts max-rejection-attempts)
                           (throw (ex-info "mh-query: exceeded max attempts" {}))
                           (let [result (try
                                          {:value (thunk)}
                                          (catch :default e
                                            (if (rejection? e)
                                              ::rejected
                                              (throw e))))]
                             (if (= result ::rejected)
                               (recur (inc attempts))
                               (:value result))))))]
      (loop [i 0, samples []]
        (if (>= i num-samples)
          samples
          (do
            (dotimes [_ lag] (sample-one))
            (recur (inc i) (conj samples (sample-one))))))))

  (defn enumeration-query-fn [thunk]
    (let [n 1000
          samples (loop [i 0, results []]
                    (if (>= i n)
                      results
                      (let [result (try
                                    {:value (thunk)}
                                    (catch :default e
                                      (if (rejection? e)
                                        ::rejected
                                        (throw e))))]
                        (if (= result ::rejected)
                          (recur (inc i) results)
                          (recur (inc i) (conj results (:value result)))))))
          freqs (frequencies samples)
          total (count samples)
          values (keys freqs)
          probs (map #(/ (get freqs %) total) values)]
      (list (apply list values) (apply list probs))))

  (defn conditional-fn [params thunk]
    (let [params-vec (vec params)
          strategy (when (seq params-vec) (name (first params-vec)))]
      (case strategy
        "enumerate" (fn [] (let [[vs ps] (enumeration-query-fn thunk)]
                             (erp/multinomial (vec vs) (vec ps))))
        "rejection" (fn [] (rejection-query-fn thunk))
        "mh" (let [lag (if (>= (count params-vec) 2) (second params-vec) 1)]
               (fn [] (first (mh-query-fn 1 lag thunk))))
        (fn [] (rejection-query-fn thunk)))))

  (js/console.log "prob.inference loaded")
  </script>

  <!-- Core (public API) -->
  <script type="application/x-scittle">
  (ns prob.core
    (:require [prob.erp :as erp]
              [prob.inference :as inference]))

  (def flip erp/flip)
  (def gaussian erp/gaussian)
  (def uniform erp/uniform)
  (def uniform-draw erp/uniform-draw)
  (def random-integer erp/random-integer)
  (def multinomial erp/multinomial)
  (def sample-discrete erp/sample-discrete)
  (def beta erp/beta)
  (def gamma erp/gamma)
  (def dirichlet erp/dirichlet)
  (def exponential erp/exponential)

  (def condition inference/condition)
  (def factor inference/factor)
  (def rejection-query-fn inference/rejection-query-fn)
  (def mh-query-fn inference/mh-query-fn)
  (def enumeration-query-fn inference/enumeration-query-fn)
  (def conditional-fn inference/conditional-fn)

  (defn mem [f]
    (let [cache (atom {})]
      (fn [& args]
        (if-let [cached (find @cache args)]
          (val cached)
          (let [result (apply f args)]
            (swap! cache assoc args result)
            result)))))

  (defn mean [lst]
    (let [a (vec lst) n (count a)]
      (/ (reduce + 0 a) n)))

  (defn variance [lst]
    (let [a (vec lst) n (count a) m (/ (reduce + 0 a) n)]
      (/ (reduce + 0 (map #(js/Math.pow (- % m) 2) a)) n)))

  (defn sum [lst] (reduce + 0 lst))
  (defn prod [lst] (reduce * 1 lst))

  (js/console.log "prob.core loaded")
  </script>

  <!-- Macros -->
  <script type="application/x-scittle">
  (ns prob.macros)

  (defmacro rejection-query [& body]
    `(prob.core/rejection-query-fn (fn [] ~@body)))

  (defmacro mh-query [n lag & body]
    `(prob.core/mh-query-fn ~n ~lag (fn [] ~@body)))

  (defmacro enumeration-query [& body]
    `(prob.core/enumeration-query-fn (fn [] ~@body)))

  (js/console.log "prob.macros loaded")
  </script>

  <!-- Demo -->
  <script type="application/x-scittle">
  (require '[prob.core :refer [flip gaussian beta uniform uniform-draw
                                condition factor mem mean variance
                                rejection-query-fn mh-query-fn
                                enumeration-query-fn]])
  (require '[prob.macros :refer [rejection-query mh-query enumeration-query]])

  (def out (js/document.getElementById "output"))
  (def btn (js/document.getElementById "run-btn"))

  (defn log [& args]
    (set! (.-textContent out)
          (str (.-textContent out) (apply str args) "\n")))

  (defn run-demo []
    (set! (.-textContent out) "")
    (set! (.-disabled btn) true)
    (set! (.-textContent btn) "Running...")
    (js/setTimeout
      (fn []
        (try
          (log "=== Rejection Query ===")
          (log "Conditioned flip: "
            (rejection-query (let [x (flip)] (condition x) x)))

          (log "\n=== Bias Estimation (MH, 500 samples) ===")
          (let [data [true true true false true true false true true true]
                samples (mh-query 500 1
                          (let [bias (beta 1 1)]
                            (doseq [obs data]
                              (condition (= obs (flip bias))))
                            bias))]
            (log "Observations: " data)
            (log "Estimated bias: " (.toFixed (mean samples) 3) " (expected ~0.8)"))

          (log "\n=== Enumeration Query ===")
          (let [[values probs] (enumeration-query
                                 (let [a (flip) b (flip)]
                                   (condition (or a b))
                                   (list a b)))]
            (log "P(a,b | a or b):")
            (doseq [[v p] (map vector values probs)]
              (log "  " v " -> " (.toFixed p 3))))

          (log "\n=== Memoized Random Function ===")
          (let [eye-color (mem (fn [person]
                                 (uniform-draw ["blue" "brown" "green"])))]
            (log "Alice: " (eye-color "alice"))
            (log "Alice (same!): " (eye-color "alice"))
            (log "Bob: " (eye-color "bob")))

          (log "\n=== Fair Coin (1000 samples) ===")
          (let [samples (mh-query 1000 1 (if (flip) 1 0))]
            (log "Mean: " (.toFixed (mean samples) 3) " (expected ~0.5)")
            (log "Variance: " (.toFixed (variance samples) 3) " (expected ~0.25)"))

          (log "\nDone!")
          (catch :default e
            (log "\nError: " (.-message e))))
        (set! (.-disabled btn) false)
        (set! (.-textContent btn) "Run again"))
      50))

  (set! (.-disabled btn) false)
  (set! (.-textContent btn) "Run inference")
  (set! (.-onclick btn) run-demo)
  (js/console.log "demo ready")
  </script>
</body>
</html>
